import {
  Suspense,
  Transition,
  computed,
  defineComponent,
  h,
  onBeforeUnmount,
  onMounted,
  ref,
  vShow,
  withDirectives
} from "vue";
import { defu } from "defu";
import { useNinjaPausableTimeout } from "../composables/useNinjaPausableTimeout.mjs";
import { useNinjaToasterContainer } from "../composables/useNinjaToasterContainer.mjs";
import { createNinjaToasterState } from "../composables/useNinjaToasterState.mjs";
import { createRenderQueue } from "../queue.mjs";
export default defineComponent({
  name: "NinjaToaster",
  props: {
    content: {
      type: [String, Number, Object, Function],
      required: true
    },
    duration: {
      type: Number,
      default: 5e3
    },
    theme: {
      type: Object,
      default: () => ({})
    },
    dismissible: {
      type: Boolean,
      default: true
    },
    pauseOnHover: {
      type: Boolean,
      default: true
    },
    queues: {
      type: Map,
      default: () => /* @__PURE__ */ new Map()
    },
    events: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["close", "click", "show"],
  setup(props, { emit }) {
    const theme = computed(() => {
      return defu(props.theme ?? {}, {
        containerClass: [],
        wrapperClass: [],
        containerId: "nt-container",
        maxToasts: Infinity,
        transition: void 0
      });
    });
    const { container, containerId } = useNinjaToasterContainer(theme);
    const timer = useNinjaPausableTimeout(() => {
      close();
    }, props.duration);
    const isHovered = ref(false);
    const isActive = ref(false);
    const unqueue = ref();
    const rootElement = ref();
    let queue;
    if (props.queues.has(containerId.value)) {
      queue = props.queues.get(containerId.value);
    } else {
      queue = createRenderQueue();
      props.queues.set(containerId.value, queue);
    }
    const content = computed(() => {
      return typeof props.content === "function" ? props.content() : props.content;
    });
    const shouldQueue = () => {
      if (!container.value) {
        return false;
      }
      if (theme.value.maxToasts <= 0 || theme.value.maxToasts === Infinity) {
        return false;
      }
      return theme.value.maxToasts <= container.value.childElementCount;
    };
    function toggleTimer(pause) {
      if (!props.pauseOnHover) {
        return;
      }
      if (pause) {
        timer.pause();
        return;
      }
      timer.resume();
    }
    function stopTimer() {
      timer.stop();
      unqueue.value?.();
    }
    function close() {
      stopTimer();
      isActive.value = false;
    }
    function show() {
      if (shouldQueue()) {
        unqueue.value = queue.add({
          until: () => !shouldQueue(),
          callback: show
        });
        return;
      }
      if (!container.value || !rootElement.value) {
        return;
      }
      container.value.insertAdjacentElement("afterbegin", rootElement.value);
      isActive.value = true;
      if (props.duration > 0) {
        timer.start();
      }
      emit("show", {
        el: rootElement.value,
        close
      });
    }
    function onMouseover() {
      isHovered.value = true;
      toggleTimer(true);
    }
    function onMouseleave() {
      isHovered.value = false;
      toggleTimer(false);
    }
    function onFocus() {
      isHovered.value = true;
      toggleTimer(true);
    }
    function onBlur() {
      isHovered.value = false;
      toggleTimer(false);
    }
    function onClick(event) {
      emit("click", event);
      if (props.dismissible) {
        close();
      }
    }
    function onKeydown(event) {
      if (event.target !== event.currentTarget) {
        return;
      }
      if (event.key !== "Enter" && event.key !== " ") {
        return;
      }
      event.preventDefault();
      onClick(event);
    }
    function onAfterLeave(el) {
      emit("close");
      if (typeof theme.value?.transition?.onAfterLeave === "function") {
        theme.value?.transition.onAfterLeave(el);
      }
      if (typeof rootElement.value?.remove !== "undefined") {
        rootElement.value?.remove();
      } else {
        rootElement.value?.parentNode?.removeChild(rootElement.value);
      }
    }
    onMounted(() => {
      show();
      props.events.on("clear", close);
      props.events.on(`clear-${containerId}`, close);
    });
    onBeforeUnmount(() => {
      props.events.off("clear", close);
      props.events.off(`clear-${containerId}`, close);
    });
    createNinjaToasterState({
      timer,
      duration: props.duration,
      isHovered,
      isActive,
      click: onClick,
      close
    });
    return () => {
      const wrapper = withDirectives(
        h(
          "div",
          {
            role: "alert",
            tabindex: 0,
            class: theme.value && Array.isArray(theme.value?.wrapperClass) ? theme.value.wrapperClass.join(" ") : theme.value?.wrapperClass,
            onMouseover,
            onMouseleave,
            onFocus,
            onBlur,
            onKeydown,
            onClick
          },
          h(Suspense, null, content.value)
        ),
        [[vShow, isActive.value]]
      );
      return h(
        Transition,
        {
          ref: rootElement,
          ...theme.value?.transition || {},
          onAfterLeave
        },
        () => wrapper
      );
    };
  }
});
